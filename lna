import numpy as np
import numpy.linalg as lng

class ExponentialFunction:
    count = 0

    def __init__(self, n=3, k=None):
        if k is None:
            k = []
        self.k = k
        self.n = n
        self.x = []
        self.y = []
        ExponentialFunction.count += 1

    def aprroximate(self, x, y):
        self.x = x
        self.y = y
        sums_x = []
        sums_yx = []
        matrix = []
        for i in range(2 * self.n + 1):
            summ = 0
            for count in x:
                summ += np.e ** (count * i)
            sums_x.append(summ)
        for j in range(self.n + 1):
            sub = []
            for i in range(j, j + self.n + 1):
                sub.append(sums_x[i])
            matrix.append(sub)
        for i in range(self.n + 1):
            summ = 0
            for j in range(len(x)):
                summ += y[j] * np.e ** (x[j] * i)
            sums_yx.append(summ)
        self.k = lng.solve(matrix, sums_yx)

    def __str__(self, n=2):
        string = str(self.k[0])
        for i in range(1, len(self.k)):
            string += " + " if self.k[i] >= 0 else " "
            string += f"{round(self.k[i],4)} * x**{i}"
        return string

    def __call__(self, x):
        i = 0
        y = 0
        for count in self.k:
            y += count * np.e ** (x*i)
            i += 1
        return y

sl = ExponentialFunction()
sl.aprroximate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 90.2, 359, 638, 999.9, 1438, 1961, 2562, 3240, 4001])
print(sl(2))
