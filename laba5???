import numpy as np
import numpy.linalg as lng


class Function:
    def __init__(self, n=3, k=None):
        if k is None:
            k = []
        self.k = k
        self.n = n
        self.x = []
        self.y = []

    def __del__(self):
        del self.k
        del self.n
        del self.x
        del self.y

    def __repr__(self):
        string = str(self.k[0])
        for element in self.k[1:]:
            string += f', {element}'
        return self.n, string

    def __len__(self):
        return self.n + 1

    def residual(self):
        get_array = [self.__call__(value) for value in self.x]
        residual_array = []
        for i in range(len(self.y)):
            residual_array.append((get_array[i] - self.y[i])**2)
        return max(residual_array)


class PowerFunction(Function):
    count = 0

    def __init__(self, n=3, k=None):
        super().__init__(n, k)
        PowerFunction.count += 1

    def approximate(self, x, y):
        self.x = x
        self.y = y
        sums_x = []
        sums_yx = []
        matrix = []
        for i in range(2 * self.n + 1):
            summ = 0
            for count in x:
                summ += count ** i
            sums_x.append(summ)
        for j in range(self.n + 1):
            sub = []
            for i in range(j, j + self.n + 1):
                sub.append(sums_x[i])
            matrix.append(sub)
        for i in range(self.n + 1):
            summ = 0
            for j in range(len(x)):
                summ += y[j] * x[j] ** i
            sums_yx.append(summ)
        self.k = lng.solve(matrix, sums_yx)

    def __str__(self):
        EPS = 10**-4
        string = str(round(self.k[0], 4)) if self.k[0] > EPS else f"{self.k[0]}"
        for i in range(1, len(self.k)):
            string += " + " if self.k[i] >= 0 else " "
            string += f"{round(self.k[i], 4)} * x**{i}" if self.k[i] > EPS else f"{round(self.k[i], 10)} * x**{i}"
        return string

    def __call__(self, x):
        i = 0
        y = 0
        for count in self.k:
            y += count * x ** i
            i += 1
        return round(y, 5)

    def __len__(self):
        return super().__len__()

    def __del__(self):
        super().__del__()
        PowerFunction.count -= 1

    def __repr__(self):
        n, string = super().__repr__()
        return f'PowerFunction({n},[{string}])'

    def residual(self):
        return super().residual()


class ExponentialFunction(Function):
    count = 0

    def __init__(self, n=3, k=None):
        super().__init__(n, k)
        ExponentialFunction.count += 1

    def approximate(self, x, y):
        self.x = x
        self.y = y
        sums_x = []
        sums_yx = []
        matrix = []
        for i in range(2 * self.n + 1):
            summ = 0
            for count in x:
                summ += np.e ** (count * i)
            sums_x.append(summ)
        for j in range(self.n + 1):
            sub = []
            for i in range(j, j + self.n + 1):
                sub.append(sums_x[i])
            matrix.append(sub)
        for i in range(self.n + 1):
            summ = 0
            for j in range(len(x)):
                summ += y[j] * np.e ** (x[j] * i)
            sums_yx.append(summ)
        self.k = lng.solve(matrix, sums_yx)

    def __str__(self):
        string = str(round(self.k[0], 4))
        for i in range(1, len(self.k)):
            string += " + " if self.k[i] >= 0 else " "
            string += f"{round(self.k[i],4)} * e^{i}x"
        return string

    def __call__(self, x):
        i = 0
        y = 0
        for count in self.k:
            y += count * np.e**(x * i)
            i += 1
        return round(y, 5)

    def __len__(self):
        return super().__len__()

    def __del__(self):
        super().__del__()
        ExponentialFunction.count -= 1

    def __repr__(self):
        n, string = super().__repr__()
        return f'ExponentialFunction({n}, [{string}])'

    def residual(self):
        return super().residual()


# x = [10, 30, 60, 80, 100, 120, 140, 160, 180, 200]
# y = [10, 90.2, 359, 638, 999.9, 1438, 1961, 2562, 3240, 4001]
# sl = PowerFunction(4)
# sl.approximate(x, y)
# print(sl(220))
# x = [1, 1.2, 1.4, 1.7, 2, 2.4, 2.8, 3.2, 3.6, 4]
# y = [1100, 920, 850, 830, 800, 785, 770, 760, 750, 745]
# sl = PowerFunction(5)
# sl.approximate(x, y)
# print(sl(5), sl.residual())
